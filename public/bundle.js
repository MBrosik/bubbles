!function(Q){var U={};function F(B){if(U[B])return U[B].exports;var I=U[B]={i:B,l:!1,exports:{}};return Q[B].call(I.exports,I,I.exports,F),I.l=!0,I.exports}F.m=Q,F.c=U,F.d=function(Q,U,B){F.o(Q,U)||Object.defineProperty(Q,U,{enumerable:!0,get:B})},F.r=function(Q){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(Q,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(Q,"__esModule",{value:!0})},F.t=function(Q,U){if(1&U&&(Q=F(Q)),8&U)return Q;if(4&U&&"object"==typeof Q&&Q&&Q.__esModule)return Q;var B=Object.create(null);if(F.r(B),Object.defineProperty(B,"default",{enumerable:!0,value:Q}),2&U&&"string"!=typeof Q)for(var I in Q)F.d(B,I,function(U){return Q[U]}.bind(null,I));return B},F.n=function(Q){var U=Q&&Q.__esModule?function(){return Q.default}:function(){return Q};return F.d(U,"a",U),U},F.o=function(Q,U){return Object.prototype.hasOwnProperty.call(Q,U)},F.p="public",F(F.s=0)}([function(module,__webpack_exports__,__webpack_require__){"use strict";eval('// ESM COMPAT FLAG\n__webpack_require__.r(__webpack_exports__);\n\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, "default", function() { return /* binding */ main_Main; });\n\n// CONCATENATED MODULE: ./src/decorators/setPoints.ts\n// {@link import("../square.ts").default} \r\n/**\r\n * @description extension of square method\r\n */\r\nfunction setPoints(_target, _name, descriptor) {\r\n    let func = descriptor.value;\r\n    descriptor.value = function (...args) {\r\n        let bool = func.bind(this)(...args);\r\n        document.getElementById("points-container").innerText = this.result.toString();\r\n        return bool;\r\n    };\r\n}\r\n\n// CONCATENATED MODULE: ./src/enums/colorType.ts\n/** @description enum of colors */\r\nvar colorType;\r\n(function (colorType) {\r\n    colorType["blue"] = "blue";\r\n    colorType["purple"] = "purple";\r\n    colorType["green"] = "green";\r\n    // yellow = "yellow",\r\n    // red = "red",\r\n    // brown = "brown",\r\n    // aqua = "aqua",\r\n    // blue,\r\n    // red ,\r\n    // green\r\n})(colorType || (colorType = {}));\r\nconsole.log(colorType);\r\n// export let colorArr:colorType[] = <colorType[]> <unknown>Object.keys(colorType)\r\n\n// CONCATENATED MODULE: ./src/utils/randomEnum.ts\n/**\r\n * @description returns random Value from enum\r\n * @param anEnum enum target\r\n */\r\nfunction randomEnum(anEnum) {\r\n    let enumValues = Object.keys(anEnum)\r\n        .map(n => Number.parseInt(n))\r\n        .filter(n => !Number.isNaN(n));\r\n    if (enumValues.length == 0) {\r\n        enumValues = Object.keys(anEnum);\r\n    }\r\n    const randomIndex = enumValues[Math.floor(Math.random() * enumValues.length)];\r\n    const randomEnumValue = anEnum[randomIndex];\r\n    return randomEnumValue;\r\n}\r\n\n// CONCATENATED MODULE: ./src/NextBallsContainer.ts\n\r\n\r\n/** @description display and randomize colors */\r\nclass NextBallsContainer_NextBallsContainer {\r\n    /**\r\n     * @param parent reference to parent element\r\n     */\r\n    constructor(parent) {\r\n        this.parent = parent;\r\n        this.html = document.querySelector(".next-container");\r\n        this.arr = [];\r\n        this.randomizeColors();\r\n    }\r\n    /** @description randomize colors */\r\n    randomizeColors() {\r\n        this.arr = new Array(3).fill(null).map(el => randomEnum(colorType));\r\n        this.html.innerHTML = "";\r\n        this.arr.forEach(el => {\r\n            let ball = document.createElement("div");\r\n            ball.classList.add("ball");\r\n            ball.style.backgroundColor = el;\r\n            console.log(this.html);\r\n            this.html.appendChild(ball);\r\n        });\r\n    }\r\n}\r\n\n// CONCATENATED MODULE: ./src/pathFinder.ts\n/**\r\n * @description function which is searching the best path\r\n * @param table table of squares\r\n */\r\nfunction pathFinder(table) {\r\n    let table1 = table;\r\n    // --------------------------\r\n    // set start and meta\r\n    // --------------------------\r\n    let start = table1.find(el => el.status == "S");\r\n    let meta = table1.find(el => el.status == "M");\r\n    let toMeta = Math.sqrt(Math.pow(start.x - meta.x, 2) + Math.pow(start.y - meta.y, 2));\r\n    start.calc = { toStart: 0, toMeta: toMeta, total: toMeta, path: 0 };\r\n    // --------------------------\r\n    // create tables\r\n    // --------------------------\r\n    let openTable = [start];\r\n    let closedTable = [];\r\n    let crossSearch = [\r\n        [-1, 0],\r\n        [1, 0],\r\n        [0, -1],\r\n        [0, 1],\r\n    ];\r\n    // --------------------------\r\n    // loops\r\n    // --------------------------\r\n    while (true) {\r\n        if (openTable.length == 0)\r\n            break;\r\n        // --------------------------\r\n        // check for best Square\r\n        // --------------------------\r\n        let current = openTable.reduce((previous, current) => {\r\n            if (previous.calc.total < current.calc.total) {\r\n                return previous;\r\n            }\r\n            else if (previous.calc.total == current.calc.total && previous.calc.toMeta < current.calc.toMeta) {\r\n                return previous;\r\n            }\r\n            else {\r\n                return current;\r\n            }\r\n        });\r\n        // --------------------------\r\n        // Migrate Square\r\n        // --------------------------\r\n        openTable.removeIf(el => el == current);\r\n        closedTable.push(current);\r\n        // --------------------------\r\n        // if meta\r\n        // --------------------------\r\n        if (current == meta)\r\n            break;\r\n        // --------------------------\r\n        // check for neighbors\r\n        // --------------------------\r\n        for (const cross of crossSearch) {\r\n            let neighbor = table1.find(el => el.x == current.x + cross[0] && el.y == current.y + cross[1]);\r\n            if (neighbor == undefined)\r\n                continue;\r\n            // ---------------------------------------\r\n            // if neighbor is in closed arr or border\r\n            // ---------------------------------------\r\n            if (neighbor.status == "B" || closedTable.find(el => el == neighbor) != null)\r\n                continue;\r\n            // ---------------------------------------\r\n            // if not in openTable\r\n            // ---------------------------------------\r\n            let toParent = Math.sqrt(Math.pow(neighbor.x - current.x, 2) + Math.pow(neighbor.y - current.y, 2));\r\n            if (openTable.find(el => el == neighbor) == null) {\r\n                let toStart = Math.sqrt(Math.pow(neighbor.x - start.x, 2) + Math.pow(neighbor.y - start.y, 2));\r\n                let toMeta = Math.sqrt(Math.pow(neighbor.x - meta.x, 2) + Math.pow(neighbor.y - meta.y, 2));\r\n                let total = toStart + toMeta;\r\n                neighbor.calc = { toStart, toMeta, total, path: current.calc.path + toParent };\r\n                neighbor.parent = current;\r\n                openTable.push(neighbor);\r\n            }\r\n            // --------------------------\r\n            // change parent\r\n            // --------------------------         \r\n            else if (current.calc.path + toParent < current.calc.path) {\r\n                neighbor.parent = current;\r\n            }\r\n        }\r\n    }\r\n    // --------------------------\r\n    // set road\r\n    // --------------------------\r\n    let old = closedTable[closedTable.length - 1];\r\n    if (old == meta) {\r\n        let path = [old];\r\n        while (true) {\r\n            path.unshift(old.parent);\r\n            old = old.parent;\r\n            if (old.status == "S")\r\n                break;\r\n        }\r\n        return path;\r\n    }\r\n    else {\r\n        return null;\r\n    }\r\n}\r\n\n// CONCATENATED MODULE: ./src/decorators/changeValuesDec.ts\n/**\r\n * @description extension of main method\r\n */\r\nfunction changeValuesDec(_target, _name, descriptor) {\r\n    let func = descriptor.value;\r\n    descriptor.value = function (...args) {\r\n        func.bind(this)(...args);\r\n        // if (this.type == "ball" && type.hasOwnProperty("type")) {\r\n        if (this.type == "ball") {\r\n            this.html.innerHTML = "";\r\n            let ballHTML = document.createElement("div");\r\n            ballHTML.classList.add("ball");\r\n            ballHTML.style.backgroundColor = this.color;\r\n            this.html.appendChild(ballHTML);\r\n        }\r\n        // else if (this.type == null && type.hasOwnProperty("type")) {\r\n        else if (this.type == null) {\r\n            this.html.innerHTML = "";\r\n        }\r\n    };\r\n    return descriptor;\r\n}\r\n\n// CONCATENATED MODULE: ./src/square.ts\nvar __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\nvar __metadata = (undefined && undefined.__metadata) || function (k, v) {\r\n    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);\r\n};\r\n\r\n/**@description class which stores information about square */\r\nclass Square {\r\n    /**\r\n     *\r\n     * @param parent reference to parent class\r\n     * @param boardHTML board html element with squares\r\n     * @param x x coordinate\r\n     * @param y y coordinate\r\n     */\r\n    constructor(parent, boardHTML, x, y) {\r\n        this.parent = parent;\r\n        this.boardHTML = boardHTML;\r\n        this.x = x;\r\n        this.y = y;\r\n        this.html = document.createElement(\'div\');\r\n        this.boardHTML.appendChild(this.html);\r\n        this.type = null;\r\n        this.color = null;\r\n    }\r\n    /**\r\n     * @description functions which is used to change values of class\r\n     * @param type object with elements of class to change\r\n     */\r\n    changeValues(type) {\r\n        for (const key in type) {\r\n            this[key] = type[key];\r\n        }\r\n    }\r\n    /**@description change css of the html element */\r\n    changeBlinkingStatus(bool) {\r\n        this.html.classList[bool ? "add" : "remove"]("blinking");\r\n    }\r\n}\r\n__decorate([\r\n    changeValuesDec,\r\n    __metadata("design:type", Function),\r\n    __metadata("design:paramtypes", [Object]),\r\n    __metadata("design:returntype", void 0)\r\n], Square.prototype, "changeValues", null);\r\n\n// CONCATENATED MODULE: ./src/utils/extending.ts\n/**@description extends Array */\r\nfunction extending() {\r\n    Array.prototype.myRandom = function () {\r\n        return this[Math.floor(Math.random() * this.length)];\r\n    };\r\n    Array.prototype.removeIf = function (func) {\r\n        var i = 0;\r\n        while (i < this.length) {\r\n            if (func(this[i], i, this)) {\r\n                this.splice(i, 1);\r\n            }\r\n            else {\r\n                ++i;\r\n            }\r\n        }\r\n    };\r\n}\r\n\n// CONCATENATED MODULE: ./src/utils/useSleep.ts\n/**\r\n * @description stop the async code for chosen time\r\n * @param time time of sleep\r\n */\r\nfunction useSleep(time) {\r\n    return new Promise(resolve => {\r\n        setTimeout(function () {\r\n            resolve(true);\r\n        }, time);\r\n    });\r\n}\r\n\n// CONCATENATED MODULE: ./src/main.ts\nvar main_decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\nvar main_metadata = (undefined && undefined.__metadata) || function (k, v) {\r\n    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);\r\n};\r\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @description Main class\r\n */\r\nclass main_Main {\r\n    constructor() {\r\n        this.boardHTML = document.querySelector("#board");\r\n        this.container = document.getElementById("container");\r\n        this.lenX = 9;\r\n        this.lenY = 9;\r\n        this.board = [];\r\n        this.result = 0;\r\n        this.nextBalls = new NextBallsContainer_NextBallsContainer(this);\r\n        this.init();\r\n    }\r\n    /** @description function which is called after constructor */\r\n    init() {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            this.setRecord();\r\n            this.createSquares();\r\n            this.randomizeBalls();\r\n            this.nextBalls.randomizeColors();\r\n            this.takeTurn();\r\n        });\r\n    }\r\n    /** @description this function shows the record */\r\n    setRecord() {\r\n        let { record } = window.localStorage;\r\n        document.getElementById("record-container").innerText = record == undefined ? 0 : record;\r\n    }\r\n    /** @description create squares in array */\r\n    createSquares() {\r\n        this.boardHTML.style.gridTemplateColumns = `repeat(${this.lenY},80px)`;\r\n        this.boardHTML.style.gridTemplateRows = `repeat(${this.lenX},80px)`;\r\n        // --------------------------\r\n        // push Squares to array\r\n        // --------------------------\r\n        for (let x = 0; x < this.lenX; x++) {\r\n            for (let y = 0; y < this.lenY; y++) {\r\n                let square = new Square(this, this.boardHTML, x, y);\r\n                this.board.push(square);\r\n            }\r\n        }\r\n    }\r\n    // -----------------------------------------------\r\n    // Take turn\r\n    // -----------------------------------------------\r\n    /** @description Turn loop */\r\n    takeTurn() {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            /** @description Table for promises */\r\n            let promiseTable = [];\r\n            /** @description variable used to store clicked ball */\r\n            let chosenBall = null;\r\n            /** @description Boolean used to check if all squares are balls */\r\n            let allBall = true;\r\n            for (const square of this.board) {\r\n                // ---------------------------------------\r\n                // Add event listeners to the balls\r\n                // ---------------------------------------\r\n                if (square.type == "ball") {\r\n                    square.html.classList.add("clickable");\r\n                    square.html.onclick = () => {\r\n                        chosenBall === null || chosenBall === void 0 ? void 0 : chosenBall.changeBlinkingStatus(false);\r\n                        let table = [\r\n                            [-1, 0],\r\n                            [1, 0],\r\n                            [0, 1],\r\n                            [0, -1],\r\n                        ].filter(el1 => {\r\n                            let f_square = this.board.find(el => el.x == square.x + el1[0] && el.y == square.y + el1[1]);\r\n                            return (f_square === null || f_square === void 0 ? void 0 : f_square.type) != "ball" && f_square != undefined;\r\n                        });\r\n                        if (chosenBall != square && table.length != 0) {\r\n                            chosenBall = square;\r\n                            chosenBall.changeBlinkingStatus(true);\r\n                        }\r\n                        else {\r\n                            chosenBall = null;\r\n                        }\r\n                    };\r\n                }\r\n                // ------------------------------------------\r\n                // Add event listeners to the other squares\r\n                // ------------------------------------------\r\n                else {\r\n                    allBall = false;\r\n                    let promise = new Promise(resolve => {\r\n                        square.html.onclick = () => {\r\n                            if (chosenBall != null\r\n                                && this.getPath(chosenBall, square) != null) {\r\n                                resolve(square);\r\n                            }\r\n                        };\r\n                    });\r\n                    promiseTable.push(promise);\r\n                    square.html.onmouseleave = () => {\r\n                        this.board.forEach(el => {\r\n                            el.html.classList.remove("pathing");\r\n                        });\r\n                    };\r\n                    square.html.onmouseenter = () => {\r\n                        if (chosenBall == null)\r\n                            return;\r\n                        let nicePath = this.getPath(chosenBall, square);\r\n                        nicePath === null || nicePath === void 0 ? void 0 : nicePath.forEach(el => {\r\n                            el.html.classList.add("pathing");\r\n                        });\r\n                    };\r\n                }\r\n            }\r\n            if (allBall) {\r\n                this.endGame();\r\n                return;\r\n            }\r\n            /** @description square which is the meta of path */\r\n            let meta = yield Promise.race(promiseTable);\r\n            /** @description the shortest path*/\r\n            let nicePath = this.getPath(chosenBall, meta);\r\n            // ---------------------------------------\r\n            // clear squares\r\n            // ---------------------------------------\r\n            this.board.forEach(el => {\r\n                el.html.onclick = () => { };\r\n                el.html.onmouseleave = () => { };\r\n                el.html.onmouseenter = () => { };\r\n                el.html.setAttribute("class", "");\r\n            });\r\n            // ---------------------------------------\r\n            // swap squares\r\n            // ---------------------------------------\r\n            if (nicePath != null) {\r\n                /** @description color of the ball target*/\r\n                let color = chosenBall.color;\r\n                nicePath === null || nicePath === void 0 ? void 0 : nicePath.forEach(el => {\r\n                    el.html.classList.add("end-pathing");\r\n                });\r\n                for (let index = 1; index < nicePath.length; index++) {\r\n                    const currElement = this.board.find(el => (el.x == nicePath[index].x && el.y == nicePath[index].y));\r\n                    const prevElement = this.board.find(el => (el.x == nicePath[index - 1].x && el.y == nicePath[index - 1].y));\r\n                    currElement.changeValues({ type: "ball", color: color });\r\n                    prevElement.changeValues({ type: null, color: null });\r\n                    yield useSleep(40);\r\n                }\r\n            }\r\n            yield useSleep(300);\r\n            nicePath === null || nicePath === void 0 ? void 0 : nicePath.forEach(el => {\r\n                el.html.classList.remove("end-pathing");\r\n            });\r\n            /** @description smash balls*/\r\n            let bool = this.pointCheck();\r\n            if (!bool) {\r\n                this.randomizeBalls();\r\n                this.nextBalls.randomizeColors();\r\n                let bool = this.pointCheck();\r\n            }\r\n            this.takeTurn();\r\n        });\r\n    }\r\n    /** @description end Game void. Called when game is ended */\r\n    endGame() {\r\n        this.board.forEach(el => {\r\n            el.changeBlinkingStatus(false);\r\n            el.html.classList.remove("clickable");\r\n        });\r\n        if (parseInt(window.localStorage["record"]) < this.result || window.localStorage["record"] == undefined) {\r\n            window.localStorage["record"] = this.result;\r\n            this.setRecord();\r\n        }\r\n        /** @description download template */\r\n        let template = document.getElementById("end-game-template");\r\n        /** @description template content */\r\n        let content = template.content.cloneNode(true);\r\n        /** @description set score to endGame window */\r\n        let endGameP = content.querySelector(".end-game-p");\r\n        endGameP.innerText = `TwÃ³j wynik: ${this.result}`;\r\n        this.container.appendChild(content);\r\n    }\r\n    // ---------------------------------------\r\n    // randomize balls\r\n    // ---------------------------------------\r\n    /** @description chose square where will be ball */\r\n    randomizeBalls() {\r\n        this.nextBalls.arr.forEach(el => {\r\n            /** @description store square */\r\n            let square;\r\n            do {\r\n                square = this.board.myRandom();\r\n            } while (square.type == "ball" && !this.board.every(el => el.type == "ball"));\r\n            square.changeValues({\r\n                type: "ball",\r\n                color: el\r\n            });\r\n        });\r\n    }\r\n    /**\r\n     * @description function used to get path\r\n     * @param chosenBall start of path\r\n     * @param square end of path\r\n     */\r\n    getPath(chosenBall, square) {\r\n        /** @description create special array for path finding */\r\n        let findTable = this.board.map(el => {\r\n            return {\r\n                x: el.x,\r\n                y: el.y,\r\n                html: el.html,\r\n                status: el == chosenBall\r\n                    ? "S"\r\n                    : el == square\r\n                        ? "M"\r\n                        : el.type == "ball"\r\n                            ? "B"\r\n                            : null,\r\n            };\r\n        });\r\n        return pathFinder(findTable);\r\n    }\r\n    /** @description function used to smash the balls */\r\n    pointCheck() {\r\n        /** @description storage for balls */\r\n        let doubleArr = [];\r\n        /** @description storage for balls */\r\n        let arr;\r\n        /** @description bool that is used to show if any ball has been hit or not */\r\n        let bool = false;\r\n        /** @description function used add balls to array */\r\n        let deleteBalls = () => {\r\n            if (arr.length >= 5) {\r\n                doubleArr.push([...arr]);\r\n                bool = true;\r\n            }\r\n        };\r\n        [true, false].forEach(elBool => {\r\n            arr = [];\r\n            for (let x = 0; x < (elBool ? this.lenX : this.lenY); x++) {\r\n                for (let y = 0; y < (elBool ? this.lenY : this.lenX); y++) {\r\n                    const element = this.board.find(el => el[elBool ? "x" : "y"] == x\r\n                        && el[elBool ? "y" : "x"] == y);\r\n                    if (arr.length == 0) {\r\n                        if (element.type == "ball") {\r\n                            arr.push(element);\r\n                        }\r\n                    }\r\n                    else if (arr[arr.length - 1].color != element.color) {\r\n                        deleteBalls();\r\n                        arr = [];\r\n                        if (element.type == "ball") {\r\n                            arr.push(element);\r\n                        }\r\n                    }\r\n                    else {\r\n                        arr.push(element);\r\n                    }\r\n                }\r\n                deleteBalls();\r\n                arr = [];\r\n            }\r\n        });\r\n        let loopOver = (y1, bool, elBool) => {\r\n            let y = y1;\r\n            let x = 0;\r\n            if (!elBool) {\r\n                let z = y;\r\n                x = y;\r\n                y = bool ? this.lenY - 1 : 0;\r\n            }\r\n            while (true) {\r\n                let el = this.board.find(el => el["x"] == x\r\n                    && el["y"] == y);\r\n                if (el != undefined) {\r\n                    if (arr.length == 0) {\r\n                        if (el.type == "ball") {\r\n                            arr.push(el);\r\n                        }\r\n                    }\r\n                    else if (arr[arr.length - 1].color != el.color) {\r\n                        deleteBalls();\r\n                        arr = [];\r\n                        if (el.type == "ball") {\r\n                            arr.push(el);\r\n                        }\r\n                    }\r\n                    else {\r\n                        arr.push(el);\r\n                    }\r\n                    if (bool) {\r\n                        x++;\r\n                        y--;\r\n                    }\r\n                    else {\r\n                        x++;\r\n                        y++;\r\n                    }\r\n                }\r\n                else {\r\n                    deleteBalls();\r\n                    arr = [];\r\n                    break;\r\n                }\r\n            }\r\n        };\r\n        [true, false].forEach(elBool => {\r\n            arr = [];\r\n            let max = elBool ? this.lenY : this.lenX;\r\n            for (let y1 = 0; y1 < max; y1++) {\r\n                loopOver(y1, true, elBool);\r\n            }\r\n        });\r\n        [true, false].forEach(elBool => {\r\n            arr = [];\r\n            let max = elBool ? this.lenY : this.lenX;\r\n            for (let y1 = max - 1; y1 >= 0; y1--) {\r\n                loopOver(y1, false, elBool);\r\n            }\r\n        });\r\n        // this.setPoints(doubleArr)\r\n        for (const arr of doubleArr) {\r\n            for (const square of arr) {\r\n                if (square.type != null) {\r\n                    square.changeValues({ color: null, type: null });\r\n                    this.result++;\r\n                }\r\n            }\r\n        }\r\n        return bool;\r\n    }\r\n}\r\nmain_decorate([\r\n    setPoints,\r\n    main_metadata("design:type", Function),\r\n    main_metadata("design:paramtypes", []),\r\n    main_metadata("design:returntype", void 0)\r\n], main_Main.prototype, "pointCheck", null);\r\nwindow.addEventListener("load", () => {\r\n    new main_Main();\r\n});\r\nextending();\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvZGVjb3JhdG9ycy9zZXRQb2ludHMudHM/YWEyZCIsIndlYnBhY2s6Ly8vLi9zcmMvZW51bXMvY29sb3JUeXBlLnRzPzA2ODUiLCJ3ZWJwYWNrOi8vLy4vc3JjL3V0aWxzL3JhbmRvbUVudW0udHM/NTEzZCIsIndlYnBhY2s6Ly8vLi9zcmMvTmV4dEJhbGxzQ29udGFpbmVyLnRzP2Q3ZGUiLCJ3ZWJwYWNrOi8vLy4vc3JjL3BhdGhGaW5kZXIudHM/MDA4MiIsIndlYnBhY2s6Ly8vLi9zcmMvZGVjb3JhdG9ycy9jaGFuZ2VWYWx1ZXNEZWMudHM/NGMwNCIsIndlYnBhY2s6Ly8vLi9zcmMvc3F1YXJlLnRzPzBkY2EiLCJ3ZWJwYWNrOi8vLy4vc3JjL3V0aWxzL2V4dGVuZGluZy50cz9hNjE0Iiwid2VicGFjazovLy8uL3NyYy91dGlscy91c2VTbGVlcC50cz9jOGQ3Iiwid2VicGFjazovLy8uL3NyYy9tYWluLnRzP2NkNDkiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUNDLDBDQUEwQztBQUUzQzs7R0FFRztBQUNJLFNBQVMsU0FBUyxDQUFDLE9BQVksRUFBRSxLQUFhLEVBQUUsVUFBZTtJQUVsRSxJQUFJLElBQUksR0FBRyxVQUFVLENBQUMsS0FBSyxDQUFDO0lBRTVCLFVBQVUsQ0FBQyxLQUFLLEdBQUcsVUFBVSxHQUFHLElBQVc7UUFDdkMsSUFBSSxJQUFJLEdBQVcsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQztRQUMzQyxRQUFRLENBQUMsY0FBYyxDQUFDLGtCQUFrQixDQUFFLENBQUMsU0FBUyxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsUUFBUSxFQUFFLENBQUM7UUFFaEYsT0FBTyxJQUFJO0lBQ2YsQ0FBQztBQUNMLENBQUM7OztBQ2hCRCxrQ0FBa0M7QUFDbEMsSUFBWSxTQVdYO0FBWEQsV0FBWSxTQUFTO0lBQ2pCLDBCQUFXO0lBQ1gsOEJBQWlCO0lBQ2pC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QUV4QyxLQUFLLElBQUksRUFBRSxHQUFHLEdBQUcsR0FBRyxDQUFDLEVBQUUsRUFBRSxJQUFJLENBQUMsRUFBRSxFQUFFLEVBQUUsRUFBRTtnQkFDbkMsUUFBUSxDQUFDLEVBQUUsRUFBRSxLQUFLLEVBQUUsTUFBTSxDQUFDLENBQUM7YUFDOUI7UUFDSixDQUFDLENBQUMsQ0FBQztRQUVILDRCQUE0QjtRQUM1QixLQUFLLE1BQU0sR0FBRyxJQUFJLFNBQVMsRUFBRTtZQUMxQixLQUFLLE1BQU0sTUFBTSxJQUFJLEdBQUcsRUFBRTtnQkFDdkIsSUFBSSxNQUFNLENBQUMsSUFBSSxJQUFJLElBQUksRUFBRTtvQkFDdEIsTUFBTSxDQUFDLFlBQVksQ0FBQyxFQUFFLEtBQUssRUFBRSxJQUFJLEVBQUUsSUFBSSxFQUFFLElBQUksRUFBRSxDQUFDLENBQUM7b0JBQ2pELElBQUksQ0FBQyxNQUFNLEVBQUUsQ0FBQztpQkFDaEI7YUFDSDtTQUNIO1FBRUQsT0FBTyxJQUFJLENBQUM7SUFDZixDQUFDO0NBQ0g7QUF4SUU7SUFEQyxTQUFTOzs7OzJDQXdJVDtBQUlKLE1BQU0sQ0FBQyxnQkFBZ0IsQ0FBQyxNQUFNLEVBQUUsR0FBRyxFQUFFO0lBQ2xDLElBQUksU0FBSSxFQUFFLENBQUM7QUFDZCxDQUFDLENBQUM7QUFHRixTQUFTLEVBQUUsQ0FBQyIsImZpbGUiOiIwLmpzIiwic291cmNlc0NvbnRlbnQiOlsiXHJcbiAvLyB7QGxpbmsgaW1wb3J0KFwiLi4vc3F1YXJlLnRzXCIpLmRlZmF1bHR9IFxyXG5cclxuLyoqXHJcbiAqIEBkZXNjcmlwdGlvbiBleHRlbnNpb24gb2Ygc3F1YXJlIG1ldGhvZCBcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBzZXRQb2ludHMoX3RhcmdldDogYW55LCBfbmFtZTogc3RyaW5nLCBkZXNjcmlwdG9yOiBhbnkpIHtcclxuXHJcbiAgICBsZXQgZnVuYyA9IGRlc2NyaXB0b3IudmFsdWU7XHJcblxyXG4gICAgZGVzY3JpcHRvci52YWx1ZSA9IGZ1bmN0aW9uICguLi5hcmdzOiBhbnlbXSkge1xyXG4gICAgICAgIGxldCBib29sOmJvb2xlYW4gPSBmdW5jLmJpbmQodGhpcykoLi4uYXJncylcclxuICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInBvaW50cy1jb250YWluZXJcIikhLmlubmVyVGV4dCA9IHRoaXMucmVzdWx0LnRvU3RyaW5nKCk7XHJcblxyXG4gICAgICAgIHJldHVybiBib29sXHJcbiAgICB9XHJcbn0iLCIvKiogQGRlc2NyaXB0aW9uIGVudW0gb2YgY29sb3JzICovXHJcbmV4cG9ydCBlbnVtIGNvbG9yVHlwZXtcclxuICAgIGJsdWU9XCJibHVlXCIsXHJcbiAgICBwdXJwbGUgPSBcInB1cnBsZVwiLFxyXG4gICAgZ3JlZW4gPSBcImdyZWVuXCIsXHJcbiAgICAvLyB5ZWxsb3cgPSBcInllbGxvd1wiLFxyXG4gICAgLy8gcmVkID0gXCJyZWRcIixcclxuICAgIC8vIGJyb3duID0gXCJicm93blwiLFxyXG4gICAgLy8gYXF1YSA9IFwiYXF1YVwiLFxyXG4gICAgLy8gYmx1ZSxcclxuICAgIC8vIHJlZCAsXHJcbiAgICAvLyBncmVlblxyXG59XHJcbmNvbnNvbGUubG9nKGNvbG9yVHlwZSk7XHJcbi8vIGV4cG9ydCBsZXQgY29sb3JBcnI6Y29sb3JUeXBlW10gPSA8Y29sb3JUeXBlW10+IDx1bmtub3duPk9iamVjdC5rZXlzKGNvbG9yVHlwZSkiLCJcclxuLyoqXHJcbiAqIEBkZXNjcmlwdGlvbiByZXR1cm5zIHJhbmRvbSBWYWx1ZSBmcm9tIGVudW1cclxuICogQHBhcmFtIGFuRW51bSBlbnVtIHRhcmdldFxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gcmFuZG9tRW51bTxUPihhbkVudW06IFQpOiBUW2tleW9mIFRdIHtcclxuICBsZXQgZW51bVZhbHVlcyA9IE9iamVjdC5rZXlzKGFuRW51bSlcclxuICAgIC5tYXAobiA9PiBOdW1iZXIucGFyc2VJbnQobikpXHJcbiAgICAuZmlsdGVyKG4gPT4gIU51bWJlci5pc05hTihuKSkgYXMgdW5rbm93biBhcyBUW2tleW9mIFRdW11cclxuICBcclxuICBpZiAoZW51bVZhbHVlcy5sZW5ndGggPT0gMCkgeyAgICAgICAgXHJcbiAgICBlbnVtVmFsdWVzID0gT2JqZWN0LmtleXMoYW5FbnVtKSBhcyB1bmtub3duIGFzIFRba2V5b2YgVF1bXVxyXG4gIH1cclxuXHJcbiAgY29uc3QgcmFuZG9tSW5kZXggPSA8a2V5b2YgVD4gPHVua25vd24+IGVudW1WYWx1ZXNbTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogZW51bVZhbHVlcy5sZW5ndGgpXVxyXG4gIGNvbnN0IHJhbmRvbUVudW1WYWx1ZSA9IGFuRW51bVtyYW5kb21JbmRleF0gIFxyXG5cclxuICByZXR1cm4gcmFuZG9tRW51bVZhbHVlO1xyXG59IiwiaW1wb3J0IHsgY29sb3JUeXBlIH0gZnJvbSBcIi4vZW51bXMvY29sb3JUeXBlXCI7XHJcbmltcG9ydCBNYWluIGZyb20gXCIuL21haW5cIjtcclxuaW1wb3J0IFNxdWFyZSBmcm9tIFwiLi9zcXVhcmVcIjtcclxuaW1wb3J0IHJhbmRvbUVudW0gZnJvbSBcIi4vdXRpbHMvcmFuZG9tRW51bVwiO1xyXG5cclxuLyoqIEBkZXNjcmlwdGlvbiBkaXNwbGF5IGFuZCByYW5kb21pemUgY29sb3JzICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE5leHRCYWxsc0NvbnRhaW5lciB7XHJcbiAgIC8qKiBAZGVzY3JpcHRpb24gaHRtbCBjb250YWluZXIgd2hpY2ggcHJlc2VudHMgbmV4dCBjb2xvcnMgKi9cclxuICAgaHRtbDogSFRNTERpdkVsZW1lbnQ7XHJcbiAgIC8qKiBAZGVzY3JpcHRpb24gQXJyYXkgZm9yIG5leHQgY29sb3JzICovXHJcbiAgIGFycjogY29sb3JUeXBlW107ICAgXHJcblxyXG4gICAvKiogICAgXHJcbiAgICAqIEBwYXJhbSBwYXJlbnQgcmVmZXJlbmNlIHRvIHBhcmVudCBlbGVtZW50XHJcbiAgICAqL1xyXG4gICBjb25zdHJ1Y3RvcihcclxuICAgICAgcHVibGljIHBhcmVudDogTWFpblxyXG4gICApIHtcclxuICAgICAgdGhpcy5odG1sID0gPEhUTUxEaXZFbGVtZW50PmRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCIubmV4dC1jb250YWluZXJcIik7XHJcblxyXG4gICAgICB0aGlzLmFyciA9IFtdO1xyXG5cclxuICAgICAgdGhpcy5yYW5kb21pemVDb2xvcnMoKTtcclxuICAgfVxyXG5cclxuICAgLyoqIEBkZXNjcmlwdGlvbiByYW5kb21pemUgY29sb3JzICovXHJcbiAgIHJhbmRvbWl6ZUNvbG9ycygpIHtcclxuICAgICAgdGhpcy5hcnIgPSBuZXcgQXJyYXkoMykuZmlsbChudWxsKS5tYXAoZWwgPT4gcmFuZG9tRW51bShjb2xvclR5cGUpKVxyXG5cclxuICAgICAgdGhpcy5odG1sLmlubmVySFRNTCA9IFwiXCI7XHJcblxyXG4gICAgICB0aGlzLmFyci5mb3JFYWNoKGVsID0+IHtcclxuICAgICAgICAgbGV0IGJhbGwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xyXG4gICAgICAgICBiYWxsLmNsYXNzTGlzdC5hZGQoXCJiYWxsXCIpO1xyXG4gICAgICAgICBiYWxsLnN0eWxlLmJhY2tncm91bmRDb2xvciA9IDxzdHJpbmc+PHVua25vd24+IGVsXHJcblxyXG4gICAgICAgICBjb25zb2xlLmxvZyh0aGlzLmh0bWwpO1xyXG4gICAgICAgICBcclxuXHJcbiAgICAgICAgIHRoaXMuaHRtbC5hcHBlbmRDaGlsZChiYWxsKTtcclxuICAgICAgfSlcclxuICAgfVxyXG59IiwiaW50ZXJmYWNlIHByZVNxdWFyZSB7XHJcbiAgIHg6IG51bWJlcjtcclxuICAgeTogbnVtYmVyO1xyXG4gICBodG1sOiBIVE1MRWxlbWVudFxyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIHNxdWFyZTEgZXh0ZW5kcyBwcmVTcXVhcmUge1xyXG4gICBzdGF0dXM6IFwiU1wiIHwgXCJNXCIgfCBcIkJcIiB8IG51bGw7XHJcbn1cclxuXHJcbmludGVyZmFjZSBmaW5kU3F1YXJlIGV4dGVuZHMgcHJlU3F1YXJlIHtcclxuICAgc3RhdHVzOiBcIlNcIiB8IFwiTVwiIHwgXCJCXCIgfCBudWxsIHwgXCJSXCIgfCBcIkNcIjtcclxuICAgY2FsYz86IHtcclxuICAgICAgdG90YWw6IG51bWJlcjtcclxuICAgICAgdG9TdGFydDogbnVtYmVyO1xyXG4gICAgICB0b01ldGE6IG51bWJlcjtcclxuICAgICAgcGF0aDogbnVtYmVyO1xyXG4gICB9XHJcbiAgIHBhcmVudD86IGZpbmRTcXVhcmU7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBAZGVzY3JpcHRpb24gZnVuY3Rpb24gd2hpY2ggaXMgc2VhcmNoaW5nIHRoZSBiZXN0IHBhdGhcclxuICogQHBhcmFtIHRhYmxlIHRhYmxlIG9mIHNxdWFyZXNcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBwYXRoRmluZGVyKHRhYmxlOiBzcXVhcmUxW10pIHtcclxuXHJcbiAgIGxldCB0YWJsZTEgPSA8ZmluZFNxdWFyZVtdPnRhYmxlO1xyXG5cclxuICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgLy8gc2V0IHN0YXJ0IGFuZCBtZXRhXHJcbiAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcblxyXG4gICBsZXQgc3RhcnQgPSB0YWJsZTEuZmluZChlbCA9PiBlbC5zdGF0dXMgPT0gXCJTXCIpITtcclxuICAgbGV0IG1ldGEgPSB0YWJsZTEuZmluZChlbCA9PiBlbC5zdGF0dXMgPT0gXCJNXCIpITtcclxuXHJcbiAgIGxldCB0b01ldGEgPSBNYXRoLnNxcnQoTWF0aC5wb3coc3RhcnQueCAtIG1ldGEueCwgMikgKyBNYXRoLnBvdyhzdGFydC55IC0gbWV0YS55LCAyKSk7XHJcblxyXG4gICBzdGFydC5jYWxjID0geyB0b1N0YXJ0OiAwLCB0b01ldGE6IHRvTWV0YSwgdG90YWw6IHRvTWV0YSwgcGF0aDogMCB9XHJcblxyXG4gICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAvLyBjcmVhdGUgdGFibGVzXHJcbiAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcblxyXG4gICBsZXQgb3BlblRhYmxlOiBmaW5kU3F1YXJlW10gPSBbc3RhcnRdO1xyXG4gICBsZXQgY2xvc2VkVGFibGU6IGZpbmRTcXVhcmVbXSA9IFtdO1xyXG5cclxuICAgbGV0IGNyb3NzU2VhcmNoID0gW1xyXG4gICAgICBbLTEsIDBdLFxyXG4gICAgICBbMSwgMF0sXHJcbiAgICAgIFswLCAtMV0sXHJcbiAgICAgIFswLCAxXSxcclxuICAgXVxyXG5cclxuXHJcbiAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgIC8vIGxvb3BzXHJcbiAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcblxyXG4gICB3aGlsZSAodHJ1ZSkge1xyXG4gICAgICBpZiAob3BlblRhYmxlLmxlbmd0aCA9PSAwKSBicmVhaztcclxuICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgICAgLy8gY2hlY2sgZm9yIGJlc3QgU3F1YXJlXHJcbiAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICAgIGxldCBjdXJyZW50ID0gb3BlblRhYmxlLnJlZHVjZSgocHJldmlvdXMsIGN1cnJlbnQpID0+IHtcclxuICAgICAgICAgaWYgKHByZXZpb3VzLmNhbGMhLnRvdGFsIDwgY3VycmVudC5jYWxjIS50b3RhbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gcHJldmlvdXNcclxuICAgICAgICAgfVxyXG4gICAgICAgICBlbHNlIGlmIChwcmV2aW91cy5jYWxjIS50b3RhbCA9PSBjdXJyZW50LmNhbGMhLnRvdGFsICYmIHByZXZpb3VzLmNhbGMhLnRvTWV0YSA8IGN1cnJlbnQuY2FsYyEudG9NZXRhKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBwcmV2aW91c1xyXG4gICAgICAgICB9XHJcbiAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gY3VycmVudFxyXG4gICAgICAgICB9XHJcbiAgICAgIH0pXHJcblxyXG4gICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgICAvLyBNaWdyYXRlIFNxdWFyZVxyXG4gICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG5cclxuICAgICAgb3BlblRhYmxlLnJlbW92ZUlmKGVsID0+IGVsID09IGN1cnJlbnQpO1xyXG4gICAgICBjbG9zZWRUYWJsZS5wdXNoKGN1cnJlbnQpO1xyXG5cclxuICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgICAgLy8gaWYgbWV0YVxyXG4gICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG5cclxuICAgICAgaWYgKGN1cnJlbnQgPT0gbWV0YSkgYnJlYWs7XHJcblxyXG4gICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgICAvLyBjaGVjayBmb3IgbmVpZ2hib3JzXHJcbiAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcblxyXG4gICAgICBmb3IgKGNvbnN0IGNyb3NzIG9mIGNyb3NzU2VhcmNoKSB7XHJcbiAgICAgICAgIGxldCBuZWlnaGJvciA9IHRhYmxlMS5maW5kKGVsID0+IGVsLnggPT0gY3VycmVudC54ICsgY3Jvc3NbMF0gJiYgZWwueSA9PSBjdXJyZW50LnkgKyBjcm9zc1sxXSk7XHJcblxyXG4gICAgICAgICBpZiAobmVpZ2hib3IgPT0gdW5kZWZpbmVkKSBjb250aW51ZTtcclxuXHJcbiAgICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgICAgICAvLyBpZiBuZWlnaGJvciBpcyBpbiBjbG9zZWQgYXJyIG9yIGJvcmRlclxyXG4gICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuXHJcbiAgICAgICAgIGlmIChuZWlnaGJvci5zdGF0dXMgPT0gXCJCXCIgfHwgY2xvc2VkVGFibGUuZmluZChlbCA9PiBlbCA9PSBuZWlnaGJvcikgIT0gbnVsbCkgY29udGludWU7XHJcblxyXG4gICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgICAgICAgLy8gaWYgbm90IGluIG9wZW5UYWJsZVxyXG4gICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgICAgICAgbGV0IHRvUGFyZW50ID0gTWF0aC5zcXJ0KE1hdGgucG93KG5laWdoYm9yLnggLSBjdXJyZW50LngsIDIpICsgTWF0aC5wb3cobmVpZ2hib3IueSAtIGN1cnJlbnQueSwgMikpO1xyXG5cclxuICAgICAgICAgaWYgKG9wZW5UYWJsZS5maW5kKGVsID0+IGVsID09IG5laWdoYm9yKSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIGxldCB0b1N0YXJ0ID0gTWF0aC5zcXJ0KE1hdGgucG93KG5laWdoYm9yLnggLSBzdGFydC54LCAyKSArIE1hdGgucG93KG5laWdoYm9yLnkgLSBzdGFydC55LCAyKSk7XHJcbiAgICAgICAgICAgIGxldCB0b01ldGEgPSBNYXRoLnNxcnQoTWF0aC5wb3cobmVpZ2hib3IueCAtIG1ldGEueCwgMikgKyBNYXRoLnBvdyhuZWlnaGJvci55IC0gbWV0YS55LCAyKSk7XHJcbiAgICAgICAgICAgIGxldCB0b3RhbCA9IHRvU3RhcnQgKyB0b01ldGE7XHJcblxyXG5cclxuICAgICAgICAgICAgbmVpZ2hib3IuY2FsYyA9IHsgdG9TdGFydCwgdG9NZXRhLCB0b3RhbCwgcGF0aDogY3VycmVudC5jYWxjIS5wYXRoICsgdG9QYXJlbnQgfVxyXG4gICAgICAgICAgICBuZWlnaGJvci5wYXJlbnQgPSBjdXJyZW50O1xyXG5cclxuICAgICAgICAgICAgb3BlblRhYmxlLnB1c2gobmVpZ2hib3IpXHJcbiAgICAgICAgIH1cclxuICAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgICAgICAgLy8gY2hhbmdlIHBhcmVudFxyXG4gICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAgICAgICAgIFxyXG4gICAgICAgICBlbHNlIGlmIChjdXJyZW50LmNhbGMhLnBhdGggKyB0b1BhcmVudCAgPCBjdXJyZW50LmNhbGMhLnBhdGgpIHtcclxuICAgICAgICAgICAgbmVpZ2hib3IucGFyZW50ID0gY3VycmVudDtcclxuICAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgIH1cclxuXHJcbiAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgIC8vIHNldCByb2FkXHJcbiAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcblxyXG5cclxuICAgbGV0IG9sZCA9IGNsb3NlZFRhYmxlW2Nsb3NlZFRhYmxlLmxlbmd0aCAtIDFdO1xyXG4gICBpZiAob2xkID09IG1ldGEpIHtcclxuXHJcblxyXG4gICAgICBsZXQgcGF0aCA9IFtvbGRdO1xyXG5cclxuICAgICAgd2hpbGUgKHRydWUpIHtcclxuICAgICAgICAgcGF0aC51bnNoaWZ0KG9sZC5wYXJlbnQhKVxyXG4gICAgICAgICBvbGQgPSBvbGQucGFyZW50IVxyXG4gICAgICAgICBpZiAob2xkLnN0YXR1cyA9PSBcIlNcIikgYnJlYWs7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBwYXRoO1xyXG4gICB9XHJcbiAgIGVsc2Uge1xyXG4gICAgICByZXR1cm4gbnVsbDtcclxuICAgfVxyXG59IiwiaW1wb3J0IE1haW4gZnJvbSBcIi4uL21haW5cIjtcclxuXHJcbi8qKlxyXG4gKiBAZGVzY3JpcHRpb24gZXh0ZW5zaW9uIG9mIG1haW4gbWV0aG9kIFxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGNoYW5nZVZhbHVlc0RlYyhfdGFyZ2V0OiBhbnksIF9uYW1lOiBzdHJpbmcsIGRlc2NyaXB0b3I6IGFueSkge1xyXG5cclxuICAgIGxldCBmdW5jID0gZGVzY3JpcHRvci52YWx1ZTtcclxuXHJcbiAgICBkZXNjcmlwdG9yLnZhbHVlID0gZnVuY3Rpb24gKC4uLmFyZ3M6IGFueVtdKSB7XHJcbiAgICAgICAgZnVuYy5iaW5kKHRoaXMpKC4uLmFyZ3MpXHJcbiAgICAgICAgLy8gaWYgKHRoaXMudHlwZSA9PSBcImJhbGxcIiAmJiB0eXBlLmhhc093blByb3BlcnR5KFwidHlwZVwiKSkge1xyXG4gICAgICAgIGlmICh0aGlzLnR5cGUgPT0gXCJiYWxsXCIpIHtcclxuICAgICAgICAgICAgdGhpcy5odG1sLmlubmVySFRNTCA9IFwiXCJcclxuXHJcbiAgICAgICAgICAgIGxldCBiYWxsSFRNTCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XHJcbiAgICAgICAgICAgIGJhbGxIVE1MLmNsYXNzTGlzdC5hZGQoXCJiYWxsXCIpO1xyXG4gICAgICAgICAgICBiYWxsSFRNTC5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSA8c3RyaW5nPjx1bmtub3duPnRoaXMuY29sb3JcclxuXHJcbiAgICAgICAgICAgIHRoaXMuaHRtbC5hcHBlbmRDaGlsZChiYWxsSFRNTClcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gZWxzZSBpZiAodGhpcy50eXBlID09IG51bGwgJiYgdHlwZS5oYXNPd25Qcm9wZXJ0eShcInR5cGVcIikpIHtcclxuICAgICAgICBlbHNlIGlmICh0aGlzLnR5cGUgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICB0aGlzLmh0bWwuaW5uZXJIVE1MID0gXCJcIjtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZGVzY3JpcHRvcjtcclxufSIsImltcG9ydCB7IHNxdWFyZVR5cGUgfSBmcm9tIFwiLi90eXBlcy9zcXVhcmVUeXBlXCI7XG5pbXBvcnQgTWFpbiBmcm9tIFwiLi9tYWluXCI7XG5pbXBvcnQgeyBjb2xvclR5cGUgfSBmcm9tIFwiLi9lbnVtcy9jb2xvclR5cGVcIjtcbmltcG9ydCB7IGNoYW5nZVZhbHVlc0RlYyB9IGZyb20gXCIuL2RlY29yYXRvcnMvY2hhbmdlVmFsdWVzRGVjXCI7XG5cbi8qKkBkZXNjcmlwdGlvbiBjbGFzcyB3aGljaCBzdG9yZXMgaW5mb3JtYXRpb24gYWJvdXQgc3F1YXJlICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTcXVhcmUgaW1wbGVtZW50cyBzcXVhcmVUeXBlIHtcbiAgICAvKipAZGVzY3JpcHRpb24gc3F1YXJlIGh0bWwgZWxlbWVudCAqL1xuICAgIGh0bWw6IEhUTUxEaXZFbGVtZW50O1xuICAgIC8qKkBkZXNjcmlwdGlvbiB0eXBlIG9mIGVsZW1lbnQsIGlzIHRoYXQgYSBiYWxsIG9yIG5vdCAqL1xuICAgIHR5cGU6IFwiYmFsbFwiIHwgbnVsbDtcbiAgICAvKipAZGVzY3JpcHRpb24gY29sb3Igb2YgdGhlIGJhbGwgKi9cbiAgICBjb2xvcjogY29sb3JUeXBlIHwgbnVsbDsgICAgXG5cblxuICAgIC8qKlxuICAgICAqIFxuICAgICAqIEBwYXJhbSBwYXJlbnQgcmVmZXJlbmNlIHRvIHBhcmVudCBjbGFzc1xuICAgICAqIEBwYXJhbSBib2FyZEhUTUwgYm9hcmQgaHRtbCBlbGVtZW50IHdpdGggc3F1YXJlc1xuICAgICAqIEBwYXJhbSB4IHggY29vcmRpbmF0ZVxuICAgICAqIEBwYXJhbSB5IHkgY29vcmRpbmF0ZVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgICAgICBwdWJsaWMgcGFyZW50OiBNYWluLFxuICAgICAgICBwdWJsaWMgYm9hcmRIVE1MOiBIVE1MRGl2RWxlbWVudCxcbiAgICAgICAgcHVibGljIHg6IG51bWJlcixcbiAgICAgICAgcHVibGljIHk6IG51bWJlclxuICAgICkge1xuICAgICAgICB0aGlzLmh0bWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdGhpcy5ib2FyZEhUTUwuYXBwZW5kQ2hpbGQodGhpcy5odG1sKVxuXG4gICAgICAgIHRoaXMudHlwZSA9IG51bGw7XG4gICAgICAgIHRoaXMuY29sb3IgPSBudWxsOyAgICAgICAgXG4gICAgfSAgICBcbiAgICAvKipcbiAgICAgKiBAZGVzY3JpcHRpb24gZnVuY3Rpb25zIHdoaWNoIGlzIHVzZWQgdG8gY2hhbmdlIHZhbHVlcyBvZiBjbGFzc1xuICAgICAqIEBwYXJhbSB0eXBlIG9iamVjdCB3aXRoIGVsZW1lbnRzIG9mIGNsYXNzIHRvIGNoYW5nZVxuICAgICAqL1xuICAgIEBjaGFuZ2VWYWx1ZXNEZWMgICAgXG4gICAgY2hhbmdlVmFsdWVzKHR5cGU6IHsgW3ggaW4ga2V5b2YgdGhpc10/OiB0aGlzW3hdIH0pIHtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gdHlwZSkgeyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICB0aGlzWyg8a2V5b2YgdGhpcz5rZXkpXSA9IDxuZXZlcj50eXBlW2tleV1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKkBkZXNjcmlwdGlvbiBjaGFuZ2UgY3NzIG9mIHRoZSBodG1sIGVsZW1lbnQgKi9cbiAgICBjaGFuZ2VCbGlua2luZ1N0YXR1cyhib29sOiBCb29sZWFuKSB7XG4gICAgICAgIHRoaXMuaHRtbC5jbGFzc0xpc3RbYm9vbCA/IFwiYWRkXCIgOiBcInJlbW92ZVwiXShcImJsaW5raW5nXCIpXG4gICAgfVxufVxuXG5cbiIsImRlY2xhcmUgZ2xvYmFsIHtcclxuICAgaW50ZXJmYWNlIEFycmF5PFQ+IHtcclxuICAgICAgbXlSYW5kb20oKTogVFxyXG4gICAgICByZW1vdmVJZihmdW5jOiAoZWxlbWVudDogVCwgaW5kZXg6IG51bWJlciwgYXJyYXk6IFRbXSkgPT4gQm9vbGVhbik6IHZvaWRcclxuICAgfVxyXG59XHJcblxyXG4vKipAZGVzY3JpcHRpb24gZXh0ZW5kcyBBcnJheSAqL1xyXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBleHRlbmRpbmcoKSB7XHJcbiAgIEFycmF5LnByb3RvdHlwZS5teVJhbmRvbSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuIHRoaXNbTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogdGhpcy5sZW5ndGgpXVxyXG4gICB9XHJcblxyXG4gICBBcnJheS5wcm90b3R5cGUucmVtb3ZlSWYgPSBmdW5jdGlvbiAoZnVuYzogKGVsZW1lbnQ6IGFueSwgaW5kZXg6IG51bWJlciwgYXJyYXk6IGFueVtdKSA9PiBCb29sZWFuKSB7XHJcbiAgICAgIHZhciBpID0gMDtcclxuICAgICAgd2hpbGUgKGkgPCB0aGlzLmxlbmd0aCkge1xyXG4gICAgICAgICBpZiAoZnVuYyh0aGlzW2ldLCBpLCB0aGlzKSkge1xyXG4gICAgICAgICAgICB0aGlzLnNwbGljZShpLCAxKTtcclxuICAgICAgICAgfVxyXG4gICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgKytpO1xyXG4gICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgfVxyXG59IiwiLyoqXHJcbiAqIEBkZXNjcmlwdGlvbiBzdG9wIHRoZSBhc3luYyBjb2RlIGZvciBjaG9zZW4gdGltZVxyXG4gKiBAcGFyYW0gdGltZSB0aW1lIG9mIHNsZWVwIFxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gdXNlU2xlZXAodGltZTpudW1iZXIpe1xyXG4gICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZT0+e1xyXG4gICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgIHJlc29sdmUodHJ1ZSlcclxuICAgICAgfSx0aW1lKVxyXG4gICB9KVxyXG59IiwiaW1wb3J0IHsgc2V0UG9pbnRzIH0gZnJvbSBcIi4vZGVjb3JhdG9ycy9zZXRQb2ludHNcIjtcbmltcG9ydCBOZXh0QmFsbHNDb250YWluZXIgZnJvbSBcIi4vTmV4dEJhbGxzQ29udGFpbmVyXCI7XG5pbXBvcnQgeyBwYXRoRmluZGVyLCBzcXVhcmUxIH0gZnJvbSBcIi4vcGF0aEZpbmRlclwiO1xuaW1wb3J0IFNxdWFyZSBmcm9tIFwiLi9zcXVhcmVcIjtcbmltcG9ydCBleHRlbmRpbmcgZnJvbSBcIi4vdXRpbHMvZXh0ZW5kaW5nXCI7XG5pbXBvcnQgdXNlU2xlZXAgZnJvbSBcIi4vdXRpbHMvdXNlU2xlZXBcIjtcblxuLyoqIFxuICogQGRlc2NyaXB0aW9uIE1haW4gY2xhc3NcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTWFpbiB7XG4gICAvKiogQGRlc2NyaXB0aW9uIGh0bWwgZWxlbWVudCBmb3IgZ2FtZSBib2FyZCAqL1xuICAgYm9hcmRIVE1MOiBIVE1MRGl2RWxlbWVudDtcbiAgIC8qKiBcbiAgICAqIHtAbGluayBTcXVhcmV9XG4gICAgKiBAZGVzY3JpcHRpb24gQXJyYXkgZm9yIHNxdWFyZXMgXG4gICAgKi9cbiAgIGJvYXJkOiBTcXVhcmVbXTtcbiAgIC8qKiBAZGVzY3JpcHRpb24gbGVuZ3RoIG9mIGdhbWUgYm9hcmQgaW4gWCBkaW1lbnNpb24gKi9cbiAgIGxlblg6IG51bWJlcjtcbiAgIC8qKiBAZGVzY3JpcHRpb24gbGVuZ3RoIG9mIGdhbWUgYm9hcmQgaW4gWSBkaW1lbnNpb24gKi9cbiAgIGxlblk6IG51bWJlcjtcbiAgIC8qKiBcbiAgICAqIHtAbGluayBOZXh0QmFsbHNDb250YWluZXJ9XG4gICAgKiBAZGVzY3JpcHRpb24gY2xhc3Mgd2hpY2ggaXMgdXNlZCB0byBzaG93IG5leHQgYmFsbHMgXG4gICAgKi9cbiAgIG5leHRCYWxsczogTmV4dEJhbGxzQ29udGFpbmVyO1xuICAgLyoqIEBkZXNjcmlwdGlvbiB2YXJpYWJsZSB3aGljaCBpcyB1c2VkIHRvIHN0b3JlIHNjb3JlKi9cbiAgIHJlc3VsdDogbnVtYmVyO1xuICAgLyoqIEBkZXNjcmlwdGlvbiBjb250YWluZXIgaHRtbCBlbGVtZW50Ki9cbiAgIGNvbnRhaW5lcjogSFRNTERpdkVsZW1lbnQ7XG5cblxuICAgY29uc3RydWN0b3IoKSB7XG4gICAgICB0aGlzLmJvYXJkSFRNTCA9IDxIVE1MRGl2RWxlbWVudD5kb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiI2JvYXJkXCIpO1xuICAgICAgdGhpcy5jb250YWluZXIgPSA8SFRNTERpdkVsZW1lbnQ+IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiY29udGFpbmVyXCIpO1xuICAgICAgdGhpcy5sZW5YID0gOTtcbiAgICAgIHRoaXMubGVuWSA9IDk7XG4gICAgICB0aGlzLmJvYXJkID0gW107XG5cbiAgICAgIHRoaXMucmVzdWx0ID0gMDtcblxuICAgICAgdGhpcy5uZXh0QmFsbHMgPSBuZXcgTmV4dEJhbGxzQ29udGFpbmVyKHRoaXMpOyAgICAgIFxuXG5cbiAgICAgIHRoaXMuaW5pdCgpO1xuICAgfVxuXG4gICAvKiogQGRlc2NyaXB0aW9uIGZ1bmN0aW9uIHdoaWNoIGlzIGNhbGxlZCBhZnRlciBjb25zdHJ1Y3RvciAqL1xuICAgYXN5bmMgaW5pdCgpIHtcbiAgICAgIHRoaXMuc2V0UmVjb3JkKCk7XG4gICAgICB0aGlzLmNyZWF0ZVNxdWFyZXMoKTtcbiAgICAgIHRoaXMucmFuZG9taXplQmFsbHMoKTtcbiAgICAgIHRoaXMubmV4dEJhbGxzLnJhbmRvbWl6ZUNvbG9ycygpO1xuICAgICAgdGhpcy50YWtlVHVybigpO1xuICAgfVxuXG4gICAvKiogQGRlc2NyaXB0aW9uIHRoaXMgZnVuY3Rpb24gc2hvd3MgdGhlIHJlY29yZCAqL1xuICAgc2V0UmVjb3JkKCkge1xuICAgICAgbGV0IHsgcmVjb3JkIH0gPSB3aW5kb3cubG9jYWxTdG9yYWdlXG4gICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInJlY29yZC1jb250YWluZXJcIikhLmlubmVyVGV4dCA9IHJlY29yZCA9PSB1bmRlZmluZWQgPyAwIDogcmVjb3JkO1xuICAgfVxuXG4gICAvKiogQGRlc2NyaXB0aW9uIGNyZWF0ZSBzcXVhcmVzIGluIGFycmF5ICovXG4gICBjcmVhdGVTcXVhcmVzKCkge1xuICAgICAgdGhpcy5ib2FyZEhUTUwuc3R5bGUuZ3JpZFRlbXBsYXRlQ29sdW1ucyA9IGByZXBlYXQoJHt0aGlzLmxlbll9LDgwcHgpYFxuICAgICAgdGhpcy5ib2FyZEhUTUwuc3R5bGUuZ3JpZFRlbXBsYXRlUm93cyA9IGByZXBlYXQoJHt0aGlzLmxlblh9LDgwcHgpYFxuICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgIC8vIHB1c2ggU3F1YXJlcyB0byBhcnJheVxuICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgdGhpcy5sZW5YOyB4KyspIHtcbiAgICAgICAgIGZvciAobGV0IHkgPSAwOyB5IDwgdGhpcy5sZW5ZOyB5KyspIHtcbiAgICAgICAgICAgIGxldCBzcXVhcmUgPSBuZXcgU3F1YXJlKHRoaXMsIHRoaXMuYm9hcmRIVE1MLCB4LCB5KTtcbiAgICAgICAgICAgIHRoaXMuYm9hcmQucHVzaChzcXVhcmUpO1xuICAgICAgICAgfVxuICAgICAgfVxuXG4gICB9XG5cblxuXG4gICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgLy8gVGFrZSB0dXJuXG4gICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5cbiAgIC8qKiBAZGVzY3JpcHRpb24gVHVybiBsb29wICovXG4gICBhc3luYyB0YWtlVHVybigpIHsgICAgICBcblxuICAgICAgLyoqIEBkZXNjcmlwdGlvbiBUYWJsZSBmb3IgcHJvbWlzZXMgKi9cbiAgICAgIGxldCBwcm9taXNlVGFibGU6IFByb21pc2U8U3F1YXJlPltdID0gW107XG4gICAgICAvKiogQGRlc2NyaXB0aW9uIHZhcmlhYmxlIHVzZWQgdG8gc3RvcmUgY2xpY2tlZCBiYWxsICovXG4gICAgICBsZXQgY2hvc2VuQmFsbDogU3F1YXJlIHwgbnVsbCA9IG51bGw7XG4gICAgICAvKiogQGRlc2NyaXB0aW9uIEJvb2xlYW4gdXNlZCB0byBjaGVjayBpZiBhbGwgc3F1YXJlcyBhcmUgYmFsbHMgKi9cbiAgICAgIGxldCBhbGxCYWxsID0gdHJ1ZTtcblxuICAgICAgZm9yICggY29uc3Qgc3F1YXJlIG9mIHRoaXMuYm9hcmQpIHtcblxuXG4gICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgIC8vIEFkZCBldmVudCBsaXN0ZW5lcnMgdG8gdGhlIGJhbGxzXG4gICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgICAgICAgaWYgKHNxdWFyZS50eXBlID09IFwiYmFsbFwiKSB7ICAgICAgICAgICAgXG5cbiAgICAgICAgICAgIHNxdWFyZS5odG1sLmNsYXNzTGlzdC5hZGQoXCJjbGlja2FibGVcIilcbiAgICAgICAgICAgIHNxdWFyZS5odG1sLm9uY2xpY2sgPSAoKSA9PiB7ICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICBjaG9zZW5CYWxsPy5jaGFuZ2VCbGlua2luZ1N0YXR1cyhmYWxzZSk7XG5cbiAgICAgICAgICAgICAgIGxldCB0YWJsZSA9IFtcbiAgICAgICAgICAgICAgICAgIFstMSwwXSxcbiAgICAgICAgICAgICAgICAgIFsxLDBdLFxuICAgICAgICAgICAgICAgICAgWzAsMV0sXG4gICAgICAgICAgICAgICAgICBbMCwtMV0sXG4gICAgICAgICAgICAgICBdLmZpbHRlcihlbDE9PntcbiAgICAgICAgICAgICAgICAgIGxldCBmX3NxdWFyZSA9IHRoaXMuYm9hcmQuZmluZChlbD0+ZWwueCA9PSBzcXVhcmUueCtlbDFbMF0gJiYgZWwueSA9PSBzcXVhcmUueSArIGVsMVsxXSlcblxuICAgICAgICAgICAgICAgICAgcmV0dXJuIGZfc3F1YXJlPy50eXBlICE9IFwiYmFsbFwiICYmIGZfc3F1YXJlIT11bmRlZmluZWRcbiAgICAgICAgICAgICAgIH0pXG5cbiAgICAgICAgICAgICAgIGlmIChjaG9zZW5CYWxsICE9IHNxdWFyZSAgJiYgdGFibGUubGVuZ3RoICE9MCkge1xuICAgICAgICAgICAgICAgICAgY2hvc2VuQmFsbCA9IHNxdWFyZTtcbiAgICAgICAgICAgICAgICAgIGNob3NlbkJhbGwuY2hhbmdlQmxpbmtpbmdTdGF0dXModHJ1ZSk7XG4gICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIGNob3NlbkJhbGwgPSBudWxsO1xuICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgfVxuXG4gICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgIC8vIEFkZCBldmVudCBsaXN0ZW5lcnMgdG8gdGhlIG90aGVyIHNxdWFyZXNcbiAgICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBhbGxCYWxsID0gZmFsc2U7XG5cbiAgICAgICAgICAgIGxldCBwcm9taXNlOiBQcm9taXNlPFNxdWFyZT4gPSBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgICAgICAgICAgIHNxdWFyZS5odG1sLm9uY2xpY2sgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgICBjaG9zZW5CYWxsICE9IG51bGxcbiAgICAgICAgICAgICAgICAgICAgICYmIHRoaXMuZ2V0UGF0aChjaG9zZW5CYWxsLCBzcXVhcmUpICE9IG51bGxcbiAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShzcXVhcmUpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHByb21pc2VUYWJsZS5wdXNoKHByb21pc2UpO1xuXG4gICAgICAgICAgICBzcXVhcmUuaHRtbC5vbm1vdXNlbGVhdmUgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICB0aGlzLmJvYXJkLmZvckVhY2goZWwgPT4ge1xuICAgICAgICAgICAgICAgICAgZWwuaHRtbC5jbGFzc0xpc3QucmVtb3ZlKFwicGF0aGluZ1wiKTtcbiAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHNxdWFyZS5odG1sLm9ubW91c2VlbnRlciA9ICgpID0+IHtcbiAgICAgICAgICAgICAgIGlmIChjaG9zZW5CYWxsID09IG51bGwpIHJldHVybjtcblxuICAgICAgICAgICAgICAgbGV0IG5pY2VQYXRoID0gdGhpcy5nZXRQYXRoKGNob3NlbkJhbGwsIHNxdWFyZSk7XG5cbiAgICAgICAgICAgICAgIG5pY2VQYXRoPy5mb3JFYWNoKGVsID0+IHtcbiAgICAgICAgICAgICAgICAgIGVsLmh0bWwuY2xhc3NMaXN0LmFkZChcInBhdGhpbmdcIik7XG4gICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfVxuICAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoYWxsQmFsbCkge1xuICAgICAgICAgdGhpcy5lbmRHYW1lKCk7XG4gICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgLyoqIEBkZXNjcmlwdGlvbiBzcXVhcmUgd2hpY2ggaXMgdGhlIG1ldGEgb2YgcGF0aCAqL1xuICAgICAgbGV0IG1ldGEgPSBhd2FpdCBQcm9taXNlLnJhY2UocHJvbWlzZVRhYmxlKTtcblxuICAgICAgLyoqIEBkZXNjcmlwdGlvbiB0aGUgc2hvcnRlc3QgcGF0aCovXG4gICAgICBsZXQgbmljZVBhdGggPSB0aGlzLmdldFBhdGgoY2hvc2VuQmFsbCEsIG1ldGEpOyAgXG5cbiAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgLy8gY2xlYXIgc3F1YXJlc1xuICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAgIHRoaXMuYm9hcmQuZm9yRWFjaChlbCA9PiB7XG4gICAgICAgICBlbC5odG1sLm9uY2xpY2sgPSAoKSA9PiB7IH07XG4gICAgICAgICBlbC5odG1sLm9ubW91c2VsZWF2ZSA9ICgpID0+IHsgfTtcbiAgICAgICAgIGVsLmh0bWwub25tb3VzZWVudGVyID0gKCkgPT4geyB9O1xuICAgICAgICAgZWwuaHRtbC5zZXRBdHRyaWJ1dGUoXCJjbGFzc1wiLCBcIlwiKTtcbiAgICAgIH0pXG5cbiAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgLy8gc3dhcCBzcXVhcmVzXG4gICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgIGlmIChuaWNlUGF0aCAhPSBudWxsKSB7XG4gICAgICAgICAvKiogQGRlc2NyaXB0aW9uIGNvbG9yIG9mIHRoZSBiYWxsIHRhcmdldCovXG4gICAgICAgICBsZXQgY29sb3IgPSBjaG9zZW5CYWxsIS5jb2xvcjtcblxuICAgICAgICAgbmljZVBhdGg/LmZvckVhY2goZWwgPT4ge1xuICAgICAgICAgICAgZWwuaHRtbC5jbGFzc0xpc3QuYWRkKFwiZW5kLXBhdGhpbmdcIik7XG4gICAgICAgICB9KVxuICAgICAgICAgZm9yIChsZXQgaW5kZXggPSAxOyBpbmRleCA8IG5pY2VQYXRoLmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICAgICAgY29uc3QgY3VyckVsZW1lbnQgPSB0aGlzLmJvYXJkLmZpbmQoZWwgPT4gKGVsLnggPT0gbmljZVBhdGghW2luZGV4XS54ICYmIGVsLnkgPT0gbmljZVBhdGghW2luZGV4XS55KSkhO1xuICAgICAgICAgICAgY29uc3QgcHJldkVsZW1lbnQgPSB0aGlzLmJvYXJkLmZpbmQoZWwgPT4gKGVsLnggPT0gbmljZVBhdGghW2luZGV4IC0gMV0ueCAmJiBlbC55ID09IG5pY2VQYXRoIVtpbmRleCAtIDFdLnkpKSE7XG5cbiAgICAgICAgICAgIGN1cnJFbGVtZW50LmNoYW5nZVZhbHVlcyh7IHR5cGU6IFwiYmFsbFwiLCBjb2xvcjogY29sb3IgfSk7XG4gICAgICAgICAgICBwcmV2RWxlbWVudC5jaGFuZ2VWYWx1ZXMoeyB0eXBlOiBudWxsLCBjb2xvcjogbnVsbCB9KTtcblxuICAgICAgICAgICAgYXdhaXQgdXNlU2xlZXAoNDApXG4gICAgICAgICB9XG5cbiAgICAgIH1cblxuXG5cbiAgICAgIGF3YWl0IHVzZVNsZWVwKDMwMClcblxuICAgICAgbmljZVBhdGg/LmZvckVhY2goZWwgPT4ge1xuICAgICAgICAgZWwuaHRtbC5jbGFzc0xpc3QucmVtb3ZlKFwiZW5kLXBhdGhpbmdcIik7XG4gICAgICB9KVxuXG4gICAgICAvKiogQGRlc2NyaXB0aW9uIHNtYXNoIGJhbGxzKi9cbiAgICAgIGxldCBib29sID0gdGhpcy5wb2ludENoZWNrKCk7XG5cbiAgICAgIGlmICghYm9vbCkge1xuICAgICAgICAgdGhpcy5yYW5kb21pemVCYWxscygpO1xuICAgICAgICAgdGhpcy5uZXh0QmFsbHMucmFuZG9taXplQ29sb3JzKCk7XG4gICAgICAgICBsZXQgYm9vbCA9IHRoaXMucG9pbnRDaGVjaygpO1xuICAgICAgfVxuXG5cblxuICAgICAgdGhpcy50YWtlVHVybigpO1xuICAgfVxuXG4gICAvKiogQGRlc2NyaXB0aW9uIGVuZCBHYW1lIHZvaWQuIENhbGxlZCB3aGVuIGdhbWUgaXMgZW5kZWQgKi9cbiAgIGVuZEdhbWUoKSB7XG4gICAgICB0aGlzLmJvYXJkLmZvckVhY2goZWwgPT4ge1xuICAgICAgICAgZWwuY2hhbmdlQmxpbmtpbmdTdGF0dXMoZmFsc2UpO1xuICAgICAgICAgZWwuaHRtbC5jbGFzc0xpc3QucmVtb3ZlKFwiY2xpY2thYmxlXCIpO1xuICAgICAgfSlcblxuICAgICAgaWYgKHBhcnNlSW50KHdpbmRvdy5sb2NhbFN0b3JhZ2VbXCJyZWNvcmRcIl0pIDwgdGhpcy5yZXN1bHQgfHwgd2luZG93LmxvY2FsU3RvcmFnZVtcInJlY29yZFwiXSA9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgIHdpbmRvdy5sb2NhbFN0b3JhZ2VbXCJyZWNvcmRcIl0gPSB0aGlzLnJlc3VsdDtcbiAgICAgICAgIHRoaXMuc2V0UmVjb3JkKCk7XG4gICAgICB9XG5cbiAgICAgIC8qKiBAZGVzY3JpcHRpb24gZG93bmxvYWQgdGVtcGxhdGUgKi9cbiAgICAgIGxldCB0ZW1wbGF0ZSA9IDxIVE1MVGVtcGxhdGVFbGVtZW50PmRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiZW5kLWdhbWUtdGVtcGxhdGVcIikhXG4gICAgICAvKiogQGRlc2NyaXB0aW9uIHRlbXBsYXRlIGNvbnRlbnQgKi9cbiAgICAgIGxldCBjb250ZW50ID0gPEhUTUxEaXZFbGVtZW50PnRlbXBsYXRlLmNvbnRlbnQuY2xvbmVOb2RlKHRydWUpXG5cbiAgICAgIC8qKiBAZGVzY3JpcHRpb24gc2V0IHNjb3JlIHRvIGVuZEdhbWUgd2luZG93ICovXG4gICAgICBsZXQgZW5kR2FtZVAgPSA8SFRNTFBhcmFncmFwaEVsZW1lbnQ+Y29udGVudC5xdWVyeVNlbGVjdG9yKFwiLmVuZC1nYW1lLXBcIikhXG4gICAgICBlbmRHYW1lUC5pbm5lclRleHQgPSBgVHfDs2ogd3luaWs6ICR7dGhpcy5yZXN1bHR9YDtcblxuICAgICAgdGhpcy5jb250YWluZXIuYXBwZW5kQ2hpbGQoY29udGVudCkgICAgICBcbiAgIH1cblxuICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAvLyByYW5kb21pemUgYmFsbHNcbiAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAvKiogQGRlc2NyaXB0aW9uIGNob3NlIHNxdWFyZSB3aGVyZSB3aWxsIGJlIGJhbGwgKi9cbiAgIHJhbmRvbWl6ZUJhbGxzKCkge1xuXG4gICAgICB0aGlzLm5leHRCYWxscy5hcnIuZm9yRWFjaChlbCA9PiB7XG4gICAgICAgICAvKiogQGRlc2NyaXB0aW9uIHN0b3JlIHNxdWFyZSAqL1xuICAgICAgICAgbGV0IHNxdWFyZTogU3F1YXJlO1xuXG4gICAgICAgICBkbyB7XG4gICAgICAgICAgICBzcXVhcmUgPSB0aGlzLmJvYXJkLm15UmFuZG9tKCk7XG4gICAgICAgICB9IHdoaWxlIChzcXVhcmUudHlwZSA9PSBcImJhbGxcIiAmJiAhdGhpcy5ib2FyZC5ldmVyeShlbCA9PiBlbC50eXBlID09IFwiYmFsbFwiKSk7XG5cbiAgICAgICAgIHNxdWFyZS5jaGFuZ2VWYWx1ZXMoe1xuICAgICAgICAgICAgdHlwZTogXCJiYWxsXCIsXG4gICAgICAgICAgICBjb2xvcjogZWxcbiAgICAgICAgIH0pO1xuICAgICAgfSlcblxuICAgfVxuXG4gICAvKipcbiAgICAqIEBkZXNjcmlwdGlvbiBmdW5jdGlvbiB1c2VkIHRvIGdldCBwYXRoIFxuICAgICogQHBhcmFtIGNob3NlbkJhbGwgc3RhcnQgb2YgcGF0aFxuICAgICogQHBhcmFtIHNxdWFyZSBlbmQgb2YgcGF0aFxuICAgICovXG4gICBnZXRQYXRoKGNob3NlbkJhbGw6IFNxdWFyZSwgc3F1YXJlOiBTcXVhcmUpIHtcbiAgICAgIC8qKiBAZGVzY3JpcHRpb24gY3JlYXRlIHNwZWNpYWwgYXJyYXkgZm9yIHBhdGggZmluZGluZyAqL1xuICAgICAgbGV0IGZpbmRUYWJsZTogc3F1YXJlMVtdID0gdGhpcy5ib2FyZC5tYXAoZWwgPT4ge1xuICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHg6IGVsLngsXG4gICAgICAgICAgICB5OiBlbC55LFxuICAgICAgICAgICAgaHRtbDogZWwuaHRtbCxcbiAgICAgICAgICAgIHN0YXR1czogZWwgPT0gY2hvc2VuQmFsbFxuICAgICAgICAgICAgICAgPyBcIlNcIlxuICAgICAgICAgICAgICAgOiBlbCA9PSBzcXVhcmVcbiAgICAgICAgICAgICAgICAgID8gXCJNXCJcbiAgICAgICAgICAgICAgICAgIDogZWwudHlwZSA9PSBcImJhbGxcIlxuICAgICAgICAgICAgICAgICAgICAgPyBcIkJcIlxuICAgICAgICAgICAgICAgICAgICAgOiBudWxsLFxuICAgICAgICAgfVxuICAgICAgfSlcblxuICAgICAgcmV0dXJuIHBhdGhGaW5kZXIoZmluZFRhYmxlKTtcbiAgIH1cblxuICAgLyoqIEBkZXNjcmlwdGlvbiBmdW5jdGlvbiB1c2VkIHRvIHNtYXNoIHRoZSBiYWxscyAqL1xuICAgQHNldFBvaW50c1xuICAgcG9pbnRDaGVjaygpIHtcbiAgICAgIC8qKiBAZGVzY3JpcHRpb24gc3RvcmFnZSBmb3IgYmFsbHMgKi9cbiAgICAgIGxldCBkb3VibGVBcnI6IFNxdWFyZVtdW10gPSBbXVxuICAgICAgLyoqIEBkZXNjcmlwdGlvbiBzdG9yYWdlIGZvciBiYWxscyAqL1xuICAgICAgbGV0IGFycjogU3F1YXJlW107XG4gICAgICAvKiogQGRlc2NyaXB0aW9uIGJvb2wgdGhhdCBpcyB1c2VkIHRvIHNob3cgaWYgYW55IGJhbGwgaGFzIGJlZW4gaGl0IG9yIG5vdCAqL1xuICAgICAgbGV0IGJvb2wgPSBmYWxzZTtcblxuICAgICAgLyoqIEBkZXNjcmlwdGlvbiBmdW5jdGlvbiB1c2VkIGFkZCBiYWxscyB0byBhcnJheSAqL1xuICAgICAgbGV0IGRlbGV0ZUJhbGxzID0gKCkgPT4ge1xuICAgICAgICAgaWYgKGFyci5sZW5ndGggPj0gNSkgeyAgICAgICAgICBcbiAgICAgICAgICAgIGRvdWJsZUFyci5wdXNoKFsuLi5hcnJdKVxuICAgICAgICAgICAgYm9vbCA9IHRydWU7XG4gICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIFt0cnVlLCBmYWxzZV0uZm9yRWFjaChlbEJvb2wgPT4ge1xuICAgICAgICAgYXJyID0gW107XG5cbiAgICAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgKGVsQm9vbCA/IHRoaXMubGVuWCA6IHRoaXMubGVuWSk7IHgrKykge1xuXG4gICAgICAgICAgICBmb3IgKGxldCB5ID0gMDsgeSA8IChlbEJvb2wgPyB0aGlzLmxlblkgOiB0aGlzLmxlblgpOyB5KyspIHtcbiAgICAgICAgICAgICAgIGNvbnN0IGVsZW1lbnQgPSB0aGlzLmJvYXJkLmZpbmQoZWwgPT5cbiAgICAgICAgICAgICAgICAgIGVsW2VsQm9vbCA/IFwieFwiIDogXCJ5XCJdID09IHhcbiAgICAgICAgICAgICAgICAgICYmIGVsW2VsQm9vbCA/IFwieVwiIDogXCJ4XCJdID09IHlcbiAgICAgICAgICAgICAgICkhO1xuXG4gICAgICAgICAgICAgICBpZiAoYXJyLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoZWxlbWVudC50eXBlID09IFwiYmFsbFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICBhcnIucHVzaChlbGVtZW50KTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgIGVsc2UgaWYgKGFyclthcnIubGVuZ3RoIC0gMV0uY29sb3IgIT0gZWxlbWVudC5jb2xvcikge1xuICAgICAgICAgICAgICAgICAgZGVsZXRlQmFsbHMoKTtcbiAgICAgICAgICAgICAgICAgIGFyciA9IFtdXG4gICAgICAgICAgICAgICAgICBpZiAoZWxlbWVudC50eXBlID09IFwiYmFsbFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICBhcnIucHVzaChlbGVtZW50KVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICBhcnIucHVzaChlbGVtZW50KVxuICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBkZWxldGVCYWxscygpO1xuXG4gICAgICAgICAgICBhcnIgPSBbXVxuICAgICAgICAgfVxuICAgICAgfSk7XG4gICAgIFxuICAgICAgbGV0IGxvb3BPdmVyID0gKHkxOiBudW1iZXIsIGJvb2w6IGJvb2xlYW4sIGVsQm9vbDogYm9vbGVhbikgPT4ge1xuICAgICAgICAgbGV0IHkgPSB5MTtcbiAgICAgICAgIGxldCB4ID0gMDtcblxuICAgICAgICAgaWYgKCFlbEJvb2wpIHtcbiAgICAgICAgICAgIGxldCB6ID0geTtcbiAgICAgICAgICAgIHggPSB5O1xuXG4gICAgICAgICAgICB5ID0gYm9vbCA/IHRoaXMubGVuWSAtIDEgOiAwO1xuICAgICAgICAgfVxuXG4gICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgbGV0IGVsOiBTcXVhcmUgPSB0aGlzLmJvYXJkLmZpbmQoZWwgPT5cbiAgICAgICAgICAgICAgIGVsW1wieFwiXSA9PSB4XG4gICAgICAgICAgICAgICAmJiBlbFtcInlcIl0gPT0geVxuICAgICAgICAgICAgKSE7XG5cbiAgICAgICAgICAgIGlmIChlbCAhPSB1bmRlZmluZWQpIHtcblxuICAgICAgICAgICAgICAgaWYgKGFyci5sZW5ndGggPT0gMCkge1xuICAgICAgICAgICAgICAgICAgaWYgKGVsLnR5cGUgPT0gXCJiYWxsXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgIGFyci5wdXNoKGVsKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgIGVsc2UgaWYgKGFyclthcnIubGVuZ3RoIC0gMV0uY29sb3IgIT0gZWwuY29sb3IpIHtcbiAgICAgICAgICAgICAgICAgIGRlbGV0ZUJhbGxzKCk7XG4gICAgICAgICAgICAgICAgICBhcnIgPSBbXVxuICAgICAgICAgICAgICAgICAgaWYgKGVsLnR5cGUgPT0gXCJiYWxsXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgIGFyci5wdXNoKGVsKVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICBhcnIucHVzaChlbClcbiAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgaWYgKGJvb2wpIHtcbiAgICAgICAgICAgICAgICAgIHgrKztcbiAgICAgICAgICAgICAgICAgIHktLTtcbiAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgeCsrO1xuICAgICAgICAgICAgICAgICAgeSsrO1xuICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICBkZWxldGVCYWxscygpO1xuICAgICAgICAgICAgICAgYXJyID0gW107XG5cbiAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBbdHJ1ZSwgZmFsc2VdLmZvckVhY2goZWxCb29sID0+IHtcbiAgICAgICAgIGFyciA9IFtdXG5cbiAgICAgICAgIGxldCBtYXggPSBlbEJvb2wgPyB0aGlzLmxlblkgOiB0aGlzLmxlblhcblxuICAgICAgICAgZm9yIChsZXQgeTEgPSAwOyB5MSA8IG1heDsgeTErKykge1xuICAgICAgICAgICAgbG9vcE92ZXIoeTEsIHRydWUsIGVsQm9vbCk7XG4gICAgICAgICB9XG4gICAgICB9KTtcblxuXG4gICAgICBbdHJ1ZSwgZmFsc2VdLmZvckVhY2goZWxCb29sID0+IHtcbiAgICAgICAgIGFyciA9IFtdXG5cbiAgICAgICAgIGxldCBtYXggPSBlbEJvb2wgPyB0aGlzLmxlblkgOiB0aGlzLmxlblhcblxuICAgICAgICAgZm9yIChsZXQgeTEgPSBtYXggLSAxOyB5MSA+PSAwOyB5MS0tKSB7XG4gICAgICAgICAgICBsb29wT3Zlcih5MSwgZmFsc2UsIGVsQm9vbCk7XG4gICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgLy8gdGhpcy5zZXRQb2ludHMoZG91YmxlQXJyKVxuICAgICAgZm9yIChjb25zdCBhcnIgb2YgZG91YmxlQXJyKSB7XG4gICAgICAgICBmb3IgKGNvbnN0IHNxdWFyZSBvZiBhcnIpIHtcbiAgICAgICAgICAgIGlmIChzcXVhcmUudHlwZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICBzcXVhcmUuY2hhbmdlVmFsdWVzKHsgY29sb3I6IG51bGwsIHR5cGU6IG51bGwgfSk7XG4gICAgICAgICAgICAgICB0aGlzLnJlc3VsdCsrOyAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgfVxuICAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gYm9vbDtcbiAgIH1cbn1cblxuXG53aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImxvYWRcIiwgKCkgPT4ge1xuICAgbmV3IE1haW4oKTtcbn0pXG5cblxuZXh0ZW5kaW5nKCk7Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///0\n')}]);